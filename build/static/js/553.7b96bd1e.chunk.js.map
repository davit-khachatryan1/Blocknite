{"version":3,"file":"static/js/553.7b96bd1e.chunk.js","mappings":"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","sources":["components/Particles/index.tsx"],"sourcesContent":["import React, { useEffect, useRef, useCallback, memo } from 'react';\r\nimport { calcVW } from '../../utils/hooks/functions';\r\nimport { Particle, ParticleCanvasProps, Point } from '../../utils/interface/particles';\r\nimport { useStateProvider } from '../../context/state';\r\n\r\n\r\nconst ParticleCanvas: React.FC<ParticleCanvasProps> = ({\r\n  spaces,\r\n  minSpeed,\r\n  maxSpeed,\r\n  pointColors,\r\n  pointMinSize,\r\n  pointMaxSize,\r\n  movementDirection,\r\n  minParticles,\r\n  maxParticles,\r\n  divade,\r\n}) => {\r\n  const {windowWidth} = useStateProvider();\r\n  const canvasRef = useRef<HTMLCanvasElement | null>(null);\r\n  const particlesRef = useRef<Particle[]>([]);\r\n\r\n  const getRandomInt = useCallback((min: number, max: number): number => {\r\n    return Math.floor(Math.random() * (max - min + 1)) + min;\r\n  }, []);\r\n\r\n  const getRandomPosition = useCallback((): { x: number; y: number } => {\r\n    return {\r\n      x: getRandomInt(0, (calcVW(1920, windowWidth, 320) as number)),\r\n      y: getRandomInt(0, (calcVW(1080, windowWidth, 568) as number)),\r\n    };\r\n  }, [getRandomInt]);\r\n\r\n  const getEdgePosition = useCallback((): { x: number; y: number } => {\r\n    let x, y;\r\n    const is = Math.round(Math.random())\r\n\r\n    switch (movementDirection) {\r\n      case 'left-to-right':\r\n        x = 0;\r\n        y = getRandomInt(0, (calcVW(1080, windowWidth, 568) as number));\r\n        break;\r\n      case 'right-to-left':\r\n        x = (calcVW(1920, windowWidth, 320) as number);\r\n        y = getRandomInt(0, (calcVW(1080, windowWidth, 568) as number));\r\n        break;\r\n      case 'top-to-bottom':\r\n        x = getRandomInt(0, (calcVW(1920, windowWidth, 320) as number));\r\n        y = 0;\r\n        break;\r\n      case 'bottom-to-top':\r\n        x = getRandomInt(0, (calcVW(1920, windowWidth, 320) as number));\r\n        y = (calcVW(1080, windowWidth, 568) as number);\r\n        break;\r\n      case 'left-top-to-right-bottom':\r\n        x = is ? Math.random() * (calcVW(1920, windowWidth, 320) as number) : 0;\r\n        y = !is ? Math.random() * (calcVW(1080, windowWidth, 568) as number) : 0;\r\n        break;\r\n      case 'right-top-to-left-bottom':\r\n        x = is ? Math.random() * (calcVW(1920, windowWidth, 320) as number) : (calcVW(1920, windowWidth, 320) as number);\r\n        y = !is ? Math.random() * (calcVW(1080, windowWidth, 568) as number) : 0;\r\n        break;\r\n      case 'left-bottom-to-right-top':\r\n        x = is ? Math.random() * (calcVW(1920, windowWidth, 320) as number) : 0;\r\n        y = !is ? ((calcVW(800, windowWidth, 238) as number) + Math.random() * (calcVW(280, windowWidth, 330) as number)) : (calcVW(1080, windowWidth, 568) as number);\r\n        break;\r\n      case 'right-bottom-to-left-top':\r\n        x = is ? Math.random() * (calcVW(1920, windowWidth, 320) as number) : (calcVW(1920, windowWidth, 320) as number);\r\n        y = !is ? Math.random() * (calcVW(1080, windowWidth, 568) as number) : (calcVW(1080, windowWidth, 568) as number);\r\n        break;\r\n      default:\r\n        x = getRandomInt(0, (calcVW(1920, windowWidth, 320) as number));\r\n        y = getRandomInt(0, (calcVW(1080, windowWidth, 568) as number));\r\n        break;\r\n    }\r\n\r\n    return { x, y };\r\n  }, [getRandomInt, movementDirection]);\r\n\r\n  const createIrregularShape = useCallback((size: number): Point[] => {\r\n    const points: Point[] = [];\r\n    const numPoints = getRandomInt(5, 10); // Number of points for the irregular shape\r\n\r\n    for (let i = 0; i < numPoints; i++) {\r\n      const angle = (i / numPoints) * Math.PI * 2;\r\n      const radius = size / 2 + Math.random() * (size / 2);\r\n      points.push({\r\n        x: Math.cos(angle) * radius,\r\n        y: Math.sin(angle) * radius,\r\n      });\r\n    }\r\n\r\n    return points;\r\n  }, [getRandomInt]);\r\n\r\n  const createParticle = useCallback((initial: boolean = false): Particle => {\r\n    const { x, y } = initial ? getRandomPosition() : getEdgePosition();\r\n    let speedX = 0;\r\n    let speedY = 0;\r\n\r\n    switch (movementDirection) {\r\n      case 'left-to-right':\r\n        speedX = getRandomInt(minSpeed, maxSpeed) / 10;\r\n        break;\r\n      case 'right-to-left':\r\n        speedX = -getRandomInt(minSpeed, maxSpeed) / 10;\r\n        break;\r\n      case 'top-to-bottom':\r\n        speedY = getRandomInt(minSpeed, maxSpeed) / 10;\r\n        break;\r\n      case 'bottom-to-top':\r\n        speedY = -getRandomInt(minSpeed, maxSpeed) / 10;\r\n        break;\r\n      case 'left-top-to-right-bottom':\r\n        speedX = getRandomInt(minSpeed, maxSpeed) / 10;\r\n        speedY = getRandomInt(minSpeed, maxSpeed) / 10;\r\n        break;\r\n      case 'right-top-to-left-bottom':\r\n        speedX = -getRandomInt(minSpeed, maxSpeed) / 10;\r\n        speedY = getRandomInt(minSpeed, maxSpeed) / 10;\r\n        break;\r\n      case 'left-bottom-to-right-top':\r\n        speedX = getRandomInt(minSpeed, maxSpeed) / 5;\r\n        speedY = -getRandomInt(minSpeed, maxSpeed) / 10;\r\n        break;\r\n      case 'right-bottom-to-left-top':\r\n        speedX = -getRandomInt(minSpeed, maxSpeed) / 10;\r\n        speedY = -getRandomInt(minSpeed, maxSpeed) / 10;\r\n        break;\r\n    }\r\n\r\n    const size = getRandomInt(pointMinSize, pointMaxSize);\r\n    const color = pointColors[Math.floor(Math.random() * pointColors.length)];\r\n    const angle = Math.random() * 2 * Math.PI;\r\n    const waveAmplitude = Math.random() * 2 + 1; // Smaller, more random amplitude\r\n    const waveFrequency = Math.random() * 0.05 + 0.01; // Smaller, more random frequency\r\n    const shape = createIrregularShape(size);\r\n    return { x, y, size, speedX, speedY, color, visible: true, angle, waveAmplitude, waveFrequency, shape };\r\n  }, [getRandomPosition, getEdgePosition, getRandomInt, minSpeed, maxSpeed, pointColors, pointMinSize, pointMaxSize, movementDirection, createIrregularShape]);\r\n\r\n  const resetParticlePosition = useCallback((particle: Particle) => {\r\n    const { x, y } = getEdgePosition();\r\n    particle.x = x;\r\n    particle.y = y;\r\n    particle.visible = true;\r\n    particle.angle = Math.random() * 2 * Math.PI;\r\n    particle.waveAmplitude = Math.random() * 2 + 1;\r\n    particle.waveFrequency = Math.random() * 0.05 + 0.01;\r\n    particle.shape = createIrregularShape(particle.size);\r\n  }, [getEdgePosition, createIrregularShape]);\r\n\r\n  const isPointInPolygon = useCallback((point: Point, polygon: Point[]): boolean => {\r\n    let isInside = false;\r\n    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\r\n      const xi = polygon[i].x, yi = polygon[i].y;\r\n      const xj = polygon[j].x, yj = polygon[j].y;\r\n      const intersect = ((yi > point.y) !== (yj > point.y)) &&\r\n        (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);\r\n      if (intersect) isInside = !isInside;\r\n    }\r\n    return isInside;\r\n  }, []);\r\n\r\n  const updateParticlePosition = useCallback((particle: Particle) => {\r\n    particle.angle += particle.waveFrequency;\r\n    const waveOffset = (Math.sin(particle.angle) * particle.waveAmplitude) / divade;\r\n\r\n    switch (movementDirection) {\r\n      case 'left-to-right':\r\n        particle.x += particle.speedX;\r\n        particle.y += waveOffset;\r\n        break;\r\n      case 'right-to-left':\r\n        particle.x += particle.speedX;\r\n        particle.y += waveOffset;\r\n        break;\r\n      case 'top-to-bottom':\r\n        particle.y += particle.speedY;\r\n        particle.x += waveOffset;\r\n        break;\r\n      case 'bottom-to-top':\r\n        particle.y += particle.speedY;\r\n        particle.x += waveOffset;\r\n        break;\r\n      case 'left-top-to-right-bottom':\r\n        particle.x += particle.speedX;\r\n        particle.y += particle.speedY + waveOffset;\r\n        break;\r\n      case 'right-top-to-left-bottom':\r\n        particle.x += particle.speedX;\r\n        particle.y += particle.speedY + waveOffset;\r\n        break;\r\n      case 'left-bottom-to-right-top':\r\n        particle.x += particle.speedX;\r\n        particle.y += particle.speedY + waveOffset;\r\n        break;\r\n      case 'right-bottom-to-left-top':\r\n        particle.x += particle.speedX;\r\n        particle.y += particle.speedY + waveOffset;\r\n        break;\r\n    }\r\n\r\n    if (\r\n      (movementDirection === 'left-to-right' && particle.x > (calcVW(1920, windowWidth, 320) as number)) ||\r\n      (movementDirection === 'right-to-left' && particle.x < 0) ||\r\n      (movementDirection === 'top-to-bottom' && particle.y > (calcVW(1080, windowWidth, 568) as number)) ||\r\n      (movementDirection === 'bottom-to-top' && particle.y < 0) ||\r\n      (movementDirection === 'left-top-to-right-bottom' && (particle.x > (calcVW(1920, windowWidth, 320) as number) || particle.y > (calcVW(1080, windowWidth, 568) as number))) ||\r\n      (movementDirection === 'right-top-to-left-bottom' && (particle.x < 0 || particle.y > (calcVW(1080, windowWidth, 568) as number))) ||\r\n      (movementDirection === 'left-bottom-to-right-top' && (particle.x > (calcVW(1920, windowWidth, 320) as number) || particle.y < 0)) ||\r\n      (movementDirection === 'right-bottom-to-left-top' && (particle.x < 0 || particle.y < 0))\r\n    ) {\r\n      resetParticlePosition(particle);\r\n    }\r\n\r\n    particle.visible = spaces.some(space => isPointInPolygon({ x: particle.x, y: particle.y }, space));\r\n  }, [movementDirection, resetParticlePosition, spaces, isPointInPolygon]);\r\n\r\n  const drawParticles = useCallback((ctx: CanvasRenderingContext2D) => {\r\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\r\n    particlesRef.current.forEach(particle => {\r\n      if (particle.visible) {\r\n        ctx.fillStyle = particle.color;\r\n        ctx.beginPath();\r\n        ctx.moveTo(particle.x + particle.shape[0].x, particle.y + particle.shape[0].y);\r\n        particle.shape.forEach(point => {\r\n          ctx.lineTo(particle.x + point.x, particle.y + point.y);\r\n        });\r\n        ctx.closePath();\r\n        ctx.fill();\r\n      }\r\n    });\r\n  }, []);\r\n\r\n  const drawSpaces = useCallback((ctx: CanvasRenderingContext2D) => {\r\n    ctx.strokeStyle = '#000000';\r\n    spaces.forEach(space => {\r\n      ctx.beginPath();\r\n      ctx.moveTo(space[0].x, space[0].y);\r\n      space.forEach(point => ctx.lineTo(point.x, point.y));\r\n      ctx.closePath();\r\n      ctx.stroke();\r\n    });\r\n  }, [spaces]);\r\n\r\n  useEffect(() => {\r\n    const canvas = canvasRef.current;\r\n    const ctx = canvas?.getContext('2d');\r\n    if (ctx) {\r\n      const animate = () => {\r\n        particlesRef.current.forEach(updateParticlePosition);\r\n        drawParticles(ctx);\r\n        // drawSpaces(ctx);\r\n        requestAnimationFrame(animate);\r\n      };\r\n\r\n      if (particlesRef.current.length === 0) {\r\n        const numParticles = getRandomInt(minParticles, maxParticles);\r\n\r\n        for (let i = 0; i < numParticles; i++) {\r\n          particlesRef.current.push(createParticle(true));\r\n        }\r\n        animate();\r\n        const timout = setTimeout(() => {\r\n          clearTimeout(timout);\r\n          const createParticlesWithDelay = () => {\r\n            for (let i = 0; i < numParticles; i++) {\r\n              const timout2 = setTimeout(() => {\r\n                clearTimeout(timout2);\r\n                particlesRef.current.push(createParticle(false));\r\n              }, i * 200);\r\n            }\r\n          };\r\n          createParticlesWithDelay();\r\n        }, 1000);\r\n      }\r\n    }\r\n  }, []);\r\n\r\n  return <canvas ref={canvasRef} width={calcVW(1920, windowWidth, 320)} height={calcVW(1080, windowWidth, 568)} />;\r\n};\r\n\r\nexport default memo(ParticleCanvas);\r\n"],"names":["ParticleCanvas","_ref","spaces","minSpeed","maxSpeed","pointColors","pointMinSize","pointMaxSize","movementDirection","minParticles","maxParticles","divade","windowWidth","useStateProvider","canvasRef","useRef","particlesRef","getRandomInt","useCallback","min","max","Math","floor","random","getRandomPosition","x","calcVW","y","getEdgePosition","is","round","createIrregularShape","size","points","numPoints","i","angle","PI","radius","push","cos","sin","createParticle","initial","arguments","length","undefined","speedX","speedY","color","visible","waveAmplitude","waveFrequency","shape","resetParticlePosition","particle","isPointInPolygon","point","polygon","isInside","j","xi","yi","xj","yj","updateParticlePosition","waveOffset","some","space","drawParticles","ctx","clearRect","canvas","width","height","current","forEach","fillStyle","beginPath","moveTo","lineTo","closePath","fill","strokeStyle","stroke","useEffect","getContext","animate","requestAnimationFrame","numParticles","timout","setTimeout","clearTimeout","createParticlesWithDelay","timout2","_jsx","ref","memo"],"sourceRoot":""}